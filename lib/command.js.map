{"version":3,"file":"command.js","sources":["../node_modules/commander/lib/error.js","../node_modules/commander/lib/argument.js","../node_modules/commander/lib/help.js","../node_modules/commander/lib/option.js","../node_modules/commander/lib/suggestSimilar.js","../node_modules/commander/lib/command.js","../node_modules/commander/index.js","../src/command.ts"],"sourcesContent":["// @ts-check\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n * @class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.length > 3 && this._name.slice(-3) === '...') {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Only allow argument value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Make argument required.\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make argument optional.\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n","const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the command description to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault = option.required || option.optional ||\n        (option.isBoolean() && typeof option.defaultValue === 'boolean');\n      if (showDefault) {\n        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    }\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.substr(0, indent);\n    const columnText = str.substr(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {any} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {string | string[]} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   * Priority order of option values is default < env < cli\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @api private\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.splitOptionFlags = splitOptionFlags;\n","const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/Damerauâ€“Levenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n","const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\nconst process = require('process');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, splitOptionFlags } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\n// @ts-check\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this._args = [];\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default < config < env < cli\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this._args.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this._args.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  }\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `${invalidValueMessage} ${err.message}`;\n            this.error(message, { exitCode: err.exitCode, code: err.code });\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *     \"-p, --pepper\"\n   *     \"-p|--pepper\"\n   *     \"-p --pepper\"\n   *\n   * @example\n   * // simple boolean defaulting to undefined\n   * program.option('-p, --pepper', 'add pepper');\n   *\n   * program.pepper\n   * // => undefined\n   *\n   * --pepper\n   * program.pepper\n   * // => true\n   *\n   * // simple boolean defaulting to true (unless non-negated option is also defined)\n   * program.option('-C, --no-cheese', 'remove cheese');\n   *\n   * program.cheese\n   * // => true\n   *\n   * --no-cheese\n   * program.cheese\n   * // => false\n   *\n   * // required argument\n   * program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   * --chdir /tmp\n   * program.chdir\n   * // => \"/tmp\"\n   *\n   * // optional argument\n   * program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    return this;\n  }\n\n  /**\n   * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    this.setOptionValue(key, value);\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));\n      if (foundExt) return `${localBin}${foundExt}`;\n\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch (err) {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));\n        if (legacyName !== this._name) {\n          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach((signal) => {\n        // @ts-ignore\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableDirMessage = executableDir\n          ? `searched for local subcommand relative to directory '${executableDir}'`\n          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n        const executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      return subCommand._parseCommand(operands, unknown);\n    }\n  }\n\n  /**\n   * Check this.args against expected this._args.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this._args.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this._args.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this._args and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        try {\n          parsedValue = argument.parseArg(value, previous);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;\n            this.error(message, { exitCode: err.exitCode, code: err.code });\n          }\n          throw err;\n        }\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this._args.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    getCommandAndParents(this)\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      }\n      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let actionResult;\n      actionResult = this._chainOrCallHooks(actionResult, 'preAction');\n      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));\n      if (this.parent) {\n        actionResult = this._chainOrCall(actionResult, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      actionResult = this._chainOrCallHooks(actionResult, 'postAction');\n      return actionResult;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Lazy calling after checking for help flags from leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   *\n   * @api private\n   */\n  _checkForConflictingOptions() {\n    const definedNonDefaultOptions = this.options.filter(\n      (option) => {\n        const optionKey = option.attributeName();\n        if (this.getOptionValue(optionKey) === undefined) {\n          return false;\n        }\n        return this.getOptionValueSource(optionKey) !== 'default';\n      }\n    );\n\n    const optionsWithConflicting = definedNonDefaultOptions.filter(\n      (option) => option.conflictsWith.length > 0\n    );\n\n    optionsWithConflicting.forEach((option) => {\n      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>\n        option.conflictsWith.includes(defined.attributeName())\n      );\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return getCommandAndParents(this).reduce(\n      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),\n      {}\n    );\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {Object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, { code: 'commander.missingArgument' });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, { code: 'commander.optionMissingArgument' });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, { code: 'commander.missingMandatoryOptionValue' });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @api private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = (option) => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());\n      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());\n      if (negativeOption && (\n        (negativeOption.presetArg === undefined && optionValue === false) ||\n        (negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)\n      )) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n\n    const getErrorMessage = (option) => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, { code: 'commander.conflictingOption' });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownOption' });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, { code: 'commander.excessArguments' });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownCommand' });\n  }\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description to `str`.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {string|Command}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n/**\n * @param {Command} startCommand\n * @returns {Command[]}\n * @api private\n */\n\nfunction getCommandAndParents(startCommand) {\n  const result = [];\n  for (let command = startCommand; command; command = command.parent) {\n    result.push(command);\n  }\n  return result;\n}\n\nexports.Command = Command;\n","const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\n// @ts-check\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n// Implicit export of createArgument, createCommand, and createOption.\n\n/**\n * Expose classes\n */\n\nexports.Argument = Argument;\nexports.Command = Command;\nexports.CommanderError = CommanderError;\nexports.Help = Help;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\nexports.Option = Option;\n","#!/usr/bin/env node\nimport { Command } from 'commander';\nimport { genListEnum, SwaggerJsonTS, GenCodeResultTS, OptionsTS } from './types/index';\nimport { parseSwagger } from './utils/parseSwagger';\nimport { genTS } from './genTS';\nimport { genService } from './genService';\n\n\nconsole.log(1111);\n\n\nconst program = new Command();\n\nprogram.version('1.0.0')\n\nprogram\n  .command('clone <source> [destination]')\n  .description('clone a repository into a newly created directory')\n  .action((source, destination) => {\n    console.log('clone command called');\n  });\n\n// /**\n//  * ç”Ÿæˆä»£ç \n//  *\n//  * @param {SwaggerJsonTS} swagger æŽ¥æ”¶ jsonã€ymal æ ¼å¼çš„æ•°æ®\n//  * @param {genListEnum} genList\n//  * @return {*}  {GenCodeResultTS}\n//  */\n// export const swaggerGenCode = async (swagger: SwaggerJsonTS, genList: genListEnum[] = [], options: OptionsTS = {}): Promise<GenCodeResultTS> => {\n//   let ts,service;\n\n//   const apiInfo = await parseSwagger(swagger);\n\n//   if (genList.includes(genListEnum.ts)) {\n//     ts = genTS(apiInfo, options);\n//   }\n\n//   if (genList.includes(genListEnum.service)) {\n//     service = genService(apiInfo, options);\n//   }\n\n\n//   const result = Object.assign({apiInfo}, ts ? {ts} : {}, service ? {service}: {});\n\n//   return result;\n// }\n"],"names":["CommanderError","Error","constructor","exitCode","code","message","super","captureStackTrace","this","name","nestedError","undefined","InvalidArgumentError","require$$0","Argument","description","variadic","parseArg","defaultValue","defaultValueDescription","argChoices","required","_name","slice","length","_concatValue","value","previous","Array","isArray","concat","default","argParser","fn","choices","values","arg","includes","join","argRequired","argOptional","humanReadableArgName","nameOutput","Help","helpWidth","sortSubcommands","sortOptions","visibleCommands","cmd","commands","filter","_hidden","_hasImplicitHelpCommand","helpName","helpArgs","_helpCommandnameAndArgs","match","helpCommand","createCommand","helpOption","_helpCommandDescription","arguments","push","sort","a","b","localeCompare","visibleOptions","options","option","hidden","showShortHelpFlag","_hasHelpOption","_helpShortFlag","_findOption","showLongHelpFlag","_helpLongFlag","let","createOption","_helpFlags","_helpDescription","getSortKey","short","replace","long","visibleArguments","_argsDescription","_args","forEach","argument","find","subcommandTerm","args","map","_aliases","optionTerm","flags","argumentTerm","longestSubcommandTermLength","helper","reduce","max","command","Math","longestOptionTermLength","longestArgumentTermLength","commandUsage","cmdName","parentCmdNames","parentCmd","parent","usage","commandDescription","subcommandDescription","optionDescription","extraInfo","JSON","stringify","choice","optional","isBoolean","presetArg","envVar","argumentDescription","extraDescripton","formatHelp","termWidth","padWidth","formatItem","term","fullText","padEnd","wrap","formatList","textArray","repeat","output","argumentList","optionList","commandList","str","width","indent","minColumnWidth","columnWidth","leadingStr","substr","columnText","indentString","regex","RegExp","lines","line","i","trimRight","Option","test","mandatory","optionFlags","splitOptionFlags","shortFlag","longFlag","negate","startsWith","conflictsWith","preset","conflicts","names","env","makeOptionMandatory","hideHelp","hide","attributeName","camelcase","is","split","word","toUpperCase","flagParts","shift","maxDistance","editDistance","abs","d","j","cost","min","suggestSimilar","candidates","from","Set","searchingOptions","candidate","similar","bestDistance","distance","EventEmitter","require$$1","require$$2","require$$3","require$$4","require$$5","Command","_allowUnknownOption","_allowExcessArguments","rawArgs","processedArgs","_scriptPath","_optionValues","_optionValueSources","_storeOptionsAsProperties","_actionHandler","_executableHandler","_executableFile","_executableDir","_defaultCommandName","_exitCallback","_combineFlagAndOptionalValue","_description","_enablePositionalOptions","_passThroughOptions","_lifeCycleHooks","_showHelpAfterError","_showSuggestionAfterError","_outputConfiguration","writeOut","process","stdout","write","writeErr","stderr","getOutHelpWidth","isTTY","columns","getErrHelpWidth","outputError","_addImplicitHelpCommand","_helpCommandName","_helpConfiguration","copyInheritedSettings","sourceCommand","nameAndArgs","actionOptsOrExecDesc","execOpts","desc","opts","isDefault","noHelp","executableFile","createHelp","Object","assign","configureHelp","configuration","configureOutput","showHelpAfterError","displayHelp","showSuggestionAfterError","displaySuggestion","addCommand","createArgument","addArgument","detail","previousArgument","addHelpCommand","enableOrNameAndArgs","_findCommand","hook","event","listener","allowedValues","exitOverride","err","_exit","exit","action","expectedArgsCount","actionArgs","apply","addOption","positiveLongFlag","oname","handleOptionValue","setOptionValueWithSource","val","invalidValueMessage","valueSource","oldValue","getOptionValue","error","on","_optionEx","config","def","m","exec","requiredOption","combineFlagAndOptionalValue","combine","allowUnknownOption","allowUnknown","allowExcessArguments","allowExcess","enablePositionalOptions","positional","passThroughOptions","passThrough","storeOptionsAsProperties","storeAsProperties","key","setOptionValue","source","getOptionValueSource","_prepareUserArgs","argv","parseOptions","versions","electron","userArgs","defaultApp","nameFromFilename","parse","_parseCommand","parseAsync","_executeSubCommand","subcommand","legacyName","sourceExt","findFile","baseDir","baseName","localBin","path","resolve","fs","existsSync","extname","foundExt","ext","_checkForMissingMandatoryOptions","executableDir","resolvedScriptPath","realpathSync","dirname","localFile","basename","launchWithNode","proc","platform","unshift","incrementNodeInspectorPort","execArgv","childProcess","spawn","stdio","execPath","killed","signals","signal","kill","exitCallback","bind","executableMissing","executableDirMessage","wrappedError","runningCommand","_dispatchSubcommand","commandName","operands","unknown","subCommand","help","_checkNumberOfArguments","missingArgument","_excessArguments","_processArguments","myParseArg","parsedValue","declaredArg","index","processed","v","_chainOrCall","promise","then","_chainOrCallHooks","result","hooks","getCommandAndParents","reverse","hookedCommand","callback","hookDetail","parsed","_parseOptionsEnv","outputHelpIfRequested","_checkForConflictingOptions","checkForUnknownOptions","unknownOption","commandEvent","actionResult","emit","listenerCount","unknownCommand","anOption","missingMandatoryOptionValue","definedNonDefaultOptions","optionKey","optionsWithConflicting","conflictingAndDefined","defined","_conflictingOption","dest","maybeOption","activeVariadicOption","optionMissingArgument","indexOf","len","_versionOptionName","_version","optsWithGlobals","combinedOptions","errorOptions","outputHelp","conflictingOption","findBestOptionFromValue","optionValue","negativeOption","target","positiveOption","getErrorMessage","bestOption","flag","suggestion","candidateFlags","moreFlags","receivedArgs","s","expected","unknownName","candidateNames","alias","version","versionOption","argsDescription","aliases","_usage","filename","helpInformation","contextOptions","_getHelpContext","context","deprecatedCallback","Buffer","isBuffer","helpFlags","addHelpText","position","text","helpStr","debugOption","debugHost","debugPort","parseInt","startCommand","exports","module","program","console","log","destination"],"mappings":"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"}